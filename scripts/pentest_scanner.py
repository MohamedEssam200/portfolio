#!/usr/bin/env python3
"""
PenTest Toolkit - Network Security Scanner
Advanced vulnerability scanning and network reconnaissance tool
"""

import socket
import threading
import subprocess
import json
import sys
from datetime import datetime
import requests
import ssl
import nmap
from urllib.parse import urljoin, urlparse
import time

class NetworkScanner:
    def __init__(self, target):
        self.target = target
        self.open_ports = []
        self.services = []
        self.vulnerabilities = []
        
    def port_scan(self, start_port=1, end_port=1000):
        """Perform TCP port scan"""
        print(f"[+] Starting port scan on {self.target}")
        
        def scan_port(port):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((self.target, port))
                if result == 0:
                    self.open_ports.append(port)
                    print(f"[+] Port {port} is open")
                sock.close()
            except:
                pass
        
        threads = []
        for port in range(start_port, end_port + 1):
            thread = threading.Thread(target=scan_port, args=(port,))
            threads.append(thread)
            thread.start()
            
            # Limit concurrent threads
            if len(threads) >= 100:
                for t in threads:
                    t.join()
                threads = []
        
        # Wait for remaining threads
        for thread in threads:
            thread.join()
            
        return self.open_ports
    
    def service_detection(self):
        """Detect services running on open ports"""
        print(f"[+] Detecting services on {self.target}")
        
        common_services = {
            21: "FTP",
            22: "SSH", 
            23: "Telnet",
            25: "SMTP",
            53: "DNS",
            80: "HTTP",
            110: "POP3",
            143: "IMAP",
            443: "HTTPS",
            993: "IMAPS",
            995: "POP3S",
            3306: "MySQL",
            5432: "PostgreSQL",
            6379: "Redis",
            27017: "MongoDB"
        }
        
        for port in self.open_ports:
            service_name = common_services.get(port, "Unknown")
            
            # Try to grab banner
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(3)
                sock.connect((self.target, port))
                
                if port == 80:
                    sock.send(b"HEAD / HTTP/1.0\r\n\r\n")
                elif port == 21:
                    pass  # FTP sends banner automatically
                else:
                    sock.send(b"\r\n")
                
                banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
                sock.close()
                
                self.services.append({
                    "port": port,
                    "service": service_name,
                    "banner": banner[:100] if banner else "No banner",
                    "version": self.extract_version(banner) if banner else "Unknown"
                })
                
            except:
                self.services.append({
                    "port": port,
                    "service": service_name,
                    "banner": "Connection failed",
                    "version": "Unknown"
                })
        
        return self.services
    
    def extract_version(self, banner):
        """Extract version information from service banner"""
        if "Apache" in banner:
            try:
                return banner.split("Apache/")[1].split()[0]
            except:
                return "Apache (version unknown)"
        elif "nginx" in banner:
            try:
                return banner.split("nginx/")[1].split()[0]
            except:
                return "nginx (version unknown)"
        elif "OpenSSH" in banner:
            try:
                return banner.split("OpenSSH_")[1].split()[0]
            except:
                return "OpenSSH (version unknown)"
        return "Unknown"
    
    def vulnerability_scan(self):
        """Check for common vulnerabilities"""
        print(f"[+] Scanning for vulnerabilities on {self.target}")
        
        # Check for common web vulnerabilities
        if 80 in self.open_ports or 443 in self.open_ports:
            self.check_web_vulnerabilities()
        
        # Check for SSH vulnerabilities
        if 22 in self.open_ports:
            self.check_ssh_vulnerabilities()
        
        # Check for FTP vulnerabilities
        if 21 in self.open_ports:
            self.check_ftp_vulnerabilities()
            
        return self.vulnerabilities
    
    def check_web_vulnerabilities(self):
        """Check for web application vulnerabilities"""
        protocols = []
        if 80 in self.open_ports:
            protocols.append("http")
        if 443 in self.open_ports:
            protocols.append("https")
        
        for protocol in protocols:
            base_url = f"{protocol}://{self.target}"
            
            try:
                # Check for directory listing
                response = requests.get(f"{base_url}/admin/", timeout=5, verify=False)
                if "Index of" in response.text or "Directory listing" in response.text:
                    self.vulnerabilities.append({
                        "type": "Directory Listing",
                        "severity": "Medium",
                        "description": "Directory listing enabled on /admin/ path",
                        "port": 443 if protocol == "https" else 80,
                        "service": protocol.upper(),
                        "recommendation": "Disable directory listing and implement proper access controls"
                    })
                
                # Check for common files
                common_files = ["/robots.txt", "/.htaccess", "/config.php", "/admin.php"]
                for file_path in common_files:
                    try:
                        response = requests.get(f"{base_url}{file_path}", timeout=3, verify=False)
                        if response.status_code == 200:
                            self.vulnerabilities.append({
                                "type": "Information Disclosure",
                                "severity": "Low",
                                "description": f"Sensitive file {file_path} is accessible",
                                "port": 443 if protocol == "https" else 80,
                                "service": protocol.upper(),
                                "recommendation": f"Restrict access to {file_path} or remove if not needed"
                            })
                    except:
                        continue
                
                # Check SSL configuration for HTTPS
                if protocol == "https":
                    self.check_ssl_vulnerabilities()
                        
            except requests.RequestException:
                pass
    
    def check_ssl_vulnerabilities(self):
        """Check SSL/TLS configuration"""
        try:
            context = ssl.create_default_context()
            with socket.create_connection((self.target, 443), timeout=5) as sock:
                with context.wrap_socket(sock, server_hostname=self.target) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    
                    # Check for weak ciphers
                    if cipher and len(cipher) > 1:
                        cipher_name = cipher[0]
                        if any(weak in cipher_name.lower() for weak in ['rc4', 'des', 'md5']):
                            self.vulnerabilities.append({
                                "type": "Weak SSL Configuration",
                                "severity": "High",
                                "description": f"Weak cipher suite detected: {cipher_name}",
                                "port": 443,
                                "service": "HTTPS",
                                "recommendation": "Configure strong cipher suites and disable weak protocols"
                            })
        except:
            pass
    
    def check_ssh_vulnerabilities(self):
        """Check SSH configuration"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((self.target, 22))
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            # Check for old SSH versions
            if "OpenSSH" in banner:
                version = banner.split("OpenSSH_")[1].split()[0]
                major_version = float(version.split('.')[0] + '.' + version.split('.')[1])
                
                if major_version < 7.4:
                    self.vulnerabilities.append({
                        "type": "Outdated SSH Version",
                        "severity": "Medium",
                        "description": f"SSH version {version} has known vulnerabilities",
                        "port": 22,
                        "service": "SSH",
                        "recommendation": "Update SSH to the latest stable version"
                    })
        except:
            pass
    
    def check_ftp_vulnerabilities(self):
        """Check FTP configuration"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((self.target, 21))
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            
            # Try anonymous login
            sock.send(b"USER anonymous\r\n")
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            
            if "230" in response or "331" in response:
                self.vulnerabilities.append({
                    "type": "Anonymous FTP Access",
                    "severity": "High",
                    "description": "FTP server allows anonymous access",
                    "port": 21,
                    "service": "FTP",
                    "recommendation": "Disable anonymous FTP access and require authentication"
                })
            
            sock.close()
        except:
            pass
    
    def generate_report(self):
        """Generate comprehensive scan report"""
        report = {
            "target": self.target,
            "scan_time": datetime.now().isoformat(),
            "summary": {
                "open_ports": len(self.open_ports),
                "services": len(self.services),
                "vulnerabilities": len(self.vulnerabilities),
                "critical_high": len([v for v in self.vulnerabilities if v["severity"] in ["Critical", "High"]])
            },
            "open_ports": self.open_ports,
            "services": self.services,
            "vulnerabilities": self.vulnerabilities
        }
        
        return report

def main():
    if len(sys.argv) != 2:
        print("Usage: python3 pentest_scanner.py <target>")
        sys.exit(1)
    
    target = sys.argv[1]
    
    print(f"[+] Starting security scan of {target}")
    print("=" * 50)
    
    scanner = NetworkScanner(target)
    
    # Perform scans
    scanner.port_scan(1, 1000)
    scanner.service_detection()
    scanner.vulnerability_scan()
    
    # Generate and print report
    report = scanner.generate_report()
    print("\n" + "=" * 50)
    print("SCAN COMPLETE")
    print("=" * 50)
    print(json.dumps(report, indent=2))

if __name__ == "__main__":
    main()
